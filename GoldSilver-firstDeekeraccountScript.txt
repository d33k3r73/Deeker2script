using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Gui.Tools;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.Indicators;
using NinjaTrader.NinjaScript.DrawingTools;

namespace NinjaTrader.NinjaScript.Strategies
{
    public class ConditionalLevelStrategy : Strategy
    {
        private double levelA;
        private double levelB;
        private double levelC;
        private double levelD;
        
        // Time tracking variables
        private DateTime lastBelowLevelCTime = DateTime.MinValue;
        private DateTime lastAboveLevelATime = DateTime.MinValue;
        private DateTime lastTradeTime = DateTime.MinValue;
        
        // State tracking
        private bool hasDroppedBelowLevelC = false;
        private bool hasGoneAboveLevelA = false;
        private bool buyConditionMet = false;
        private bool sellConditionMet = false;
        
        // Trailing stop variables
        private double trailingStopPrice = 0;
        private bool isLong = false;
        private bool isShort = false;
        
        // Order tracking
        private Order buyOrder = null;
        private Order sellOrder = null;
        private Order stopOrder = null;
        
        // Level line tracking
        private List<double> levelALines = new List<double>();
        private List<double> levelBLines = new List<double>();
        private List<double> levelCLines = new List<double>();
        private List<double> levelDLines = new List<double>();

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Description = @"Strategy that places buy orders at LevelB when price drops below LevelC first, and sell orders at LevelD when price goes above LevelA first, with time constraints and trailing stops.";
                Name = "ConditionalLevelStrategy";
                Calculate = Calculate.OnEachTick; // Changed to OnEachTick for market replay
                EntriesPerDirection = 1;
                EntryHandling = EntryHandling.AllEntries;
                IsExitOnSessionCloseStrategy = true;
                ExitOnSessionCloseSeconds = 30;
                IsFillLimitOnTouch = false;
                MaximumBarsLookBack = MaximumBarsLookBack.TwoHundredFiftySix;
                OrderFillResolution = OrderFillResolution.Standard;
                Slippage = 0;
                StartBehavior = StartBehavior.WaitUntilFlat;
                TimeInForce = TimeInForce.Gtc;
                TraceOrders = false;
                RealtimeErrorHandling = RealtimeErrorHandling.StopCancelClose;
                StopTargetHandling = StopTargetHandling.PerEntryExecution;
                BarsRequiredToTrade = 20;
                IsInstantiatedOnEachOptimizationIteration = true;
                
                // Default level values - these should be set by user
                LevelA = 4150;
                LevelB = 4100;
                LevelC = 4120;
                LevelD = 4180;
                TrailingStopTicks = 4;
            }
            else if (State == State.Configure)
            {
                // Add any additional configuration here
            }
            else if (State == State.DataLoaded)
            {
                // Draw level lines when data is loaded
                DrawLevelLines();
            }
        }

        private void DrawLevelLines()
        {
            // Clear existing lines
            levelALines.Clear();
            levelBLines.Clear();
            levelCLines.Clear();
            levelDLines.Clear();
            
            // Find the price range to determine which levels to draw
            double minPrice = double.MaxValue;
            double maxPrice = double.MinValue;
            
            // Look at recent bars to determine price range
            int barsToCheck = Math.Min(500, CurrentBar);
            for (int i = 0; i < barsToCheck; i++)
            {
                if (CurrentBar - i >= 0)
                {
                    minPrice = Math.Min(minPrice, Low[i]);
                    maxPrice = Math.Max(maxPrice, High[i]);
                }
            }
            
            // Expand range slightly
            minPrice -= 100;
            maxPrice += 100;
            
            // Draw LevelA lines (every 0 level: 4000, 4100, 4200, etc.)
            for (double price = Math.Floor(minPrice / 100) * 100; price <= maxPrice; price += 100)
            {
                if (price % 100 == 0) // Every 0 level
                {
                    Draw.HorizontalLine(this, "LevelA_" + price.ToString(), price, Brushes.Red, DashStyleHelper.Solid, 2);
                    levelALines.Add(price);
                }
            }
            
            // Draw LevelB lines (every 26 level: 4026, 4126, 4226, etc.)
            for (double price = Math.Floor(minPrice / 100) * 100; price <= maxPrice; price += 100)
            {
                double levelBPrice = price + 26;
                if (levelBPrice >= minPrice && levelBPrice <= maxPrice)
                {
                    Draw.HorizontalLine(this, "LevelB_" + levelBPrice.ToString(), levelBPrice, Brushes.Blue, DashStyleHelper.Solid, 2);
                    levelBLines.Add(levelBPrice);
                }
            }
            
            // Draw LevelC lines (every 50 level: 4050, 4150, 4250, etc.)
            for (double price = Math.Floor(minPrice / 100) * 100; price <= maxPrice; price += 100)
            {
                double levelCPrice = price + 50;
                if (levelCPrice >= minPrice && levelCPrice <= maxPrice)
                {
                    Draw.HorizontalLine(this, "LevelC_" + levelCPrice.ToString(), levelCPrice, Brushes.Green, DashStyleHelper.Solid, 2);
                    levelCLines.Add(levelCPrice);
                }
            }
            
            // Draw LevelD lines (every 77 level: 4077, 4177, 4277, etc.)
            for (double price = Math.Floor(minPrice / 100) * 100; price <= maxPrice; price += 100)
            {
                double levelDPrice = price + 77;
                if (levelDPrice >= minPrice && levelDPrice <= maxPrice)
                {
                    Draw.HorizontalLine(this, "LevelD_" + levelDPrice.ToString(), levelDPrice, Brushes.Orange, DashStyleHelper.Solid, 2);
                    levelDLines.Add(levelDPrice);
                }
            }
        }

        protected override void OnBarUpdate()
        {
            if (BarsInProgress != 0 || CurrentBars[0] < BarsRequiredToTrade)
                return;

            double currentPrice = Close[0];
            DateTime currentTime = Time[0];
            
            // Use tick data if available, otherwise use bar data
            if (State == State.Realtime || IsReplayModeEnabled())
            {
                currentPrice = Close[0];
            }
            
            // Check for price dropping below any LevelC for the first time in past 30 minutes
            CheckBelowLevelC(currentPrice, currentTime);
            
            // Check for price going above any LevelA for the first time in past 30 minutes
            CheckAboveLevelA(currentPrice, currentTime);
            
            // Check buy condition at any LevelB
            CheckBuyCondition(currentPrice, currentTime);
            
            // Check sell condition at any LevelD
            CheckSellCondition(currentPrice, currentTime);
            
            // Update trailing stop
            UpdateTrailingStop(currentPrice);
            
            // Reset conditions if 30 minutes have passed
            ResetConditionsIfExpired(currentTime);
        }

        private bool IsReplayModeEnabled()
        {
            return Connection.PlaybackConnection != null;
        }

        private void CheckBelowLevelC(double currentPrice, DateTime currentTime)
        {
            // Check if price has dropped below any LevelC for the first time in past 30 minutes
            foreach (double levelCPrice in levelCLines)
            {
                if (currentPrice < levelCPrice && !hasDroppedBelowLevelC)
                {
                    // Verify this is the first time in past 30 minutes
                    bool isFirstTimeInPast30Min = true;
                    for (int i = 1; i < Math.Min(CurrentBar, GetBarsInMinutes(30)); i++)
                    {
                        if (Close[i] < levelCPrice)
                        {
                            isFirstTimeInPast30Min = false;
                            break;
                        }
                    }
                    
                    if (isFirstTimeInPast30Min)
                    {
                        hasDroppedBelowLevelC = true;
                        lastBelowLevelCTime = currentTime;
                        buyConditionMet = false; // Reset buy condition
                        levelC = levelCPrice; // Set the triggered level
                        
                        // Find corresponding LevelB (26 levels below the 50 level)
                        double correspondingLevelB = Math.Floor(levelCPrice / 100) * 100 + 26;
                        levelB = correspondingLevelB;
                        
                        Print($"Price dropped below LevelC ({levelCPrice}) for first time at {currentTime}. LevelB value: {levelB}");
                        break; // Only trigger once
                    }
                }
            }
        }

        private void CheckAboveLevelA(double currentPrice, DateTime currentTime)
        {
            // Check if price has gone above any LevelA for the first time in past 30 minutes
            foreach (double levelAPrice in levelALines)
            {
                if (currentPrice > levelAPrice && !hasGoneAboveLevelA)
                {
                    // Verify this is the first time in past 30 minutes
                    bool isFirstTimeInPast30Min = true;
                    for (int i = 1; i < Math.Min(CurrentBar, GetBarsInMinutes(30)); i++)
                    {
                        if (Close[i] > levelAPrice)
                        {
                            isFirstTimeInPast30Min = false;
                            break;
                        }
                    }
                    
                    if (isFirstTimeInPast30Min)
                    {
                        hasGoneAboveLevelA = true;
                        lastAboveLevelATime = currentTime;
                        sellConditionMet = false; // Reset sell condition
                        levelA = levelAPrice; // Set the triggered level
                        
                        // Find corresponding LevelD (77 levels above the 0 level)
                        double correspondingLevelD = Math.Floor(levelAPrice / 100) * 100 + 77;
                        levelD = correspondingLevelD;
                        
                        Print($"Price went above LevelA ({levelAPrice}) for first time at {currentTime}. LevelD value: {levelD}");
                        break; // Only trigger once
                    }
                }
            }
        }

        private void CheckBuyCondition(double currentPrice, DateTime currentTime)
        {
            // Check if we should place buy order at LevelB
            if (hasDroppedBelowLevelC && !buyConditionMet && Position.MarketPosition == MarketPosition.Flat)
            {
                // Check if within 20 minutes of dropping below LevelC
                TimeSpan timeSinceBelowC = currentTime - lastBelowLevelCTime;
                
                // Check if at least 20 minutes have passed since last trade
                TimeSpan timeSinceLastTrade = currentTime - lastTradeTime;
                bool canTrade = lastTradeTime == DateTime.MinValue || timeSinceLastTrade.TotalMinutes >= 20;
                
                if (timeSinceBelowC.TotalMinutes <= 20 && canTrade)
                {
                    // Check if price has reached LevelB
                    if (currentPrice >= levelB)
                    {
                        buyConditionMet = true;
                        lastTradeTime = currentTime;
                        EnterLongMarket("BuyAtLevelB");
                        isLong = true;
                        isShort = false;
                        trailingStopPrice = currentPrice - (TrailingStopTicks * TickSize);
                        Print($"Market buy order placed at LevelB ({levelB}) at {currentTime}. Current price: {currentPrice}");
                    }
                }
            }
        }

        private void CheckSellCondition(double currentPrice, DateTime currentTime)
        {
            // Check if we should place sell order at LevelD
            if (hasGoneAboveLevelA && !sellConditionMet && Position.MarketPosition == MarketPosition.Flat)
            {
                // Check if within 20 minutes of going above LevelA
                TimeSpan timeSinceAboveA = currentTime - lastAboveLevelATime;
                
                // Check if at least 20 minutes have passed since last trade
                TimeSpan timeSinceLastTrade = currentTime - lastTradeTime;
                bool canTrade = lastTradeTime == DateTime.MinValue || timeSinceLastTrade.TotalMinutes >= 20;
                
                if (timeSinceAboveA.TotalMinutes <= 20 && canTrade)
                {
                    // Check if price has reached LevelD
                    if (currentPrice <= levelD)
                    {
                        sellConditionMet = true;
                        lastTradeTime = currentTime;
                        EnterShortMarket("SellAtLevelD");
                        isLong = false;
                        isShort = true;
                        trailingStopPrice = currentPrice + (TrailingStopTicks * TickSize);
                        Print($"Market sell order placed at LevelD ({levelD}) at {currentTime}. Current price: {currentPrice}");
                    }
                }
            }
        }

        private void UpdateTrailingStop(double currentPrice)
        {
            if (Position.MarketPosition == MarketPosition.Flat)
            {
                isLong = false;
                isShort = false;
                return;
            }

            // Update trailing stop for long position
            if (isLong && Position.MarketPosition == MarketPosition.Long)
            {
                double newStopPrice = currentPrice - (TrailingStopTicks * TickSize);
                if (newStopPrice > trailingStopPrice)
                {
                    trailingStopPrice = newStopPrice;
                    if (stopOrder != null && stopOrder.OrderState == OrderState.Working)
                    {
                        CancelOrder(stopOrder);
                    }
                    stopOrder = ExitLongStopMarket(0, true, Position.Quantity, trailingStopPrice, "TrailingStop", "BuyAtLevelB");
                }
            }
            
            // Update trailing stop for short position
            if (isShort && Position.MarketPosition == MarketPosition.Short)
            {
                double newStopPrice = currentPrice + (TrailingStopTicks * TickSize);
                if (newStopPrice < trailingStopPrice)
                {
                    trailingStopPrice = newStopPrice;
                    if (stopOrder != null && stopOrder.OrderState == OrderState.Working)
                    {
                        CancelOrder(stopOrder);
                    }
                    stopOrder = ExitShortStopMarket(0, true, Position.Quantity, trailingStopPrice, "TrailingStop", "SellAtLevelD");
                }
            }
        }

        private void ResetConditionsIfExpired(DateTime currentTime)
        {
            // Reset buy condition if 30 minutes have passed since dropping below LevelC
            if (hasDroppedBelowLevelC && (currentTime - lastBelowLevelCTime).TotalMinutes > 30)
            {
                hasDroppedBelowLevelC = false;
                buyConditionMet = false;
            }
            
            // Reset sell condition if 30 minutes have passed since going above LevelA
            if (hasGoneAboveLevelA && (currentTime - lastAboveLevelATime).TotalMinutes > 30)
            {
                hasGoneAboveLevelA = false;
                sellConditionMet = false;
            }
        }

        private int GetBarsInMinutes(int minutes)
        {
            // Estimate bars based on bar period (this is a simplified calculation)
            if (BarsPeriod.BarsPeriodType == BarsPeriodType.Minute)
            {
                return minutes / BarsPeriod.Value;
            }
            else if (BarsPeriod.BarsPeriodType == BarsPeriodType.Second)
            {
                return (minutes * 60) / BarsPeriod.Value;
            }
            else
            {
                return minutes; // Default fallback
            }
        }

        protected override void OnOrderUpdate(Order order, double limitPrice, double stopPrice, int quantity, int filled, double averageFillPrice, OrderState orderState, DateTime time, ErrorCode error, string comment)
        {
            if (order.Name == "BuyAtLevelB")
                buyOrder = order;
            else if (order.Name == "SellAtLevelD")
                sellOrder = order;
            else if (order.Name == "TrailingStop")
                stopOrder = order;
        }

        protected override void OnExecutionUpdate(Execution execution, string executionId, double price, int quantity, MarketPosition marketPosition, string orderId, DateTime time)
        {
            if (execution.Order.Name == "BuyAtLevelB" || execution.Order.Name == "SellAtLevelD")
            {
                // Position entered, trailing stop will be managed in OnBarUpdate
                Print($"Position entered: {execution.Order.Name} at price {price}");
            }
        }

        #region Properties
        [NinjaScriptProperty]
        [Range(1, double.MaxValue)]
        [Display(Name = "Level A", Description = "Upper trigger level", Order = 1, GroupName = "Levels")]
        public double LevelA
        {
            get { return levelA; }
            set { levelA = value; }
        }

        [NinjaScriptProperty]
        [Range(1, double.MaxValue)]
        [Display(Name = "Level B", Description = "Buy order level", Order = 2, GroupName = "Levels")]
        public double LevelB
        {
            get { return levelB; }
            set { levelB = value; }
        }

        [NinjaScriptProperty]
        [Range(1, double.MaxValue)]
        [Display(Name = "Level C", Description = "Lower trigger level", Order = 3, GroupName = "Levels")]
        public double LevelC
        {
            get { return levelC; }
            set { levelC = value; }
        }

        [NinjaScriptProperty]
        [Range(1, double.MaxValue)]
        [Display(Name = "Level D", Description = "Sell order level", Order = 4, GroupName = "Levels")]
        public double LevelD
        {
            get { return levelD; }
            set { levelD = value; }
        }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "Trailing Stop Ticks", Description = "Number of ticks for trailing stop", Order = 5, GroupName = "Risk Management")]
        public int TrailingStopTicks { get; set; }
        #endregion
    }
}